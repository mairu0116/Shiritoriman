<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>しりとりゲーム</title>
  <style>
    #hand img {
      width: 100px;
      height: auto;
      margin: 5px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    #hand img:hover {
      transform: scale(1.1);
    }
  </style>
</head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>しりとりマン、襲来</title>
  <style>
    :root { --bg:#0b1020; --card:#121a32; --ink:#e6ecff; --muted:#9fb0ff; --accent:#7aa2ff; --ok:#44d7b6; --warn:#ffce54; --err:#ff6b6b }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; color:var(--ink); background: radial-gradient(1200px 600px at 10% -10%, #1b2550 0%, #0b1020 40%, #080d1a 100%); min-height: 100vh; }
    .container { max-width: 1100px; margin: 0 auto; padding: 24px; }
    .heading { display:flex; align-items:center; gap:12px; }
    .logo { width: 36px; height: 36px; border-radius: 10px; background: linear-gradient(135deg, var(--accent), #9ee7ff); filter: drop-shadow(0 6px 20px rgba(122,162,255,.35)); }
    .panel { background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:16px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .grid { display:grid; gap:16px; }
    .grid.cols-2 { grid-template-columns: 1fr 1fr; }
    .grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .grow { flex:1; }
    label { font-size: 12px; color: var(--muted); display:block; margin-bottom:4px; }
    input, button, select { background: #0f1730; color: var(--ink); border:1px solid rgba(255,255,255,.12); border-radius: 10px; padding: 10px 12px; outline: none; }
    input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(122,162,255,.2); }
    button { cursor: pointer; font-weight: 600; }
    .primary { background: linear-gradient(135deg, #5c86ff, #3fb4ff); border: none; }
    .ghost { background: transparent; border-color: rgba(255,255,255,.2); }
    .danger { background: linear-gradient(135deg, #ff6b6b, #f78ca0); border: none; }
    .success { background: linear-gradient(135deg, #44d7b6, #6be6c1); border: none; }

    /* Cards */
    .cards { display:flex; gap:10px; flex-wrap: wrap; }
    .card { width:72px; height:104px; border-radius:14px; display:flex; align-items:center; justify-content:center; position:relative; user-select:none; background: linear-gradient(180deg, #152045, #101a36); border:1px solid rgba(255,255,255,.16); box-shadow: 0 8px 18px rgba(0,0,0,.4); }
    .card .tag { position:absolute; top:6px; left:8px; font-size: 11px; color: var(--muted); opacity:.9; }
    .card .big { font-size: 36px; font-weight: 700; letter-spacing: .03em; }
    .card.kana { background: linear-gradient(180deg, #192a5a, #122149); }
    .card.wildN { background: linear-gradient(180deg, #244a63, #183b5b); }
    .card.wildL { background: linear-gradient(180deg, #5c3f85, #3a2b63); }
    .card.back { background: linear-gradient(180deg, #0c1531, #0a1229); border-style:dashed; }
    .card.small { width:56px; height:80px; }

    .stack { display:flex; align-items:center; gap:12px; }
    .stack .count { background:#0d1531; border:1px solid rgba(255,255,255,.1); padding:6px 10px; border-radius:999px; font-size:12px; color:var(--muted); }

    .section-title { font-size: 14px; color: var(--muted); margin: 6px 0 8px; letter-spacing: .06em; text-transform: uppercase; }

    .players { display:flex; gap:10px; flex-wrap:wrap; }
    .player { background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.1); border-radius:12px; padding:10px 12px; display:flex; align-items:center; gap:10px; }
    .pill { font-size:11px; padding:4px 8px; border-radius:999px; background:#0e1640; color:var(--muted); border:1px solid rgba(255,255,255,.1) }

    .hint { color:var(--muted); font-size:13px; }
    .kbd { border:1px solid rgba(255,255,255,.2); border-bottom-width:2px; padding:2px 6px; border-radius:6px; background: rgba(255,255,255,.06); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px }

    .footer { margin-top: 28px; color: var(--muted); font-size: 12px; text-align:center }
  </style>
</head>
<body>
  <div class="container">
    <div class="heading">
      <div class="logo"></div>
      <h1>しりとりマン、襲来 <small style="font-size:14px;color:var(--muted);font-weight:500">HTML5 / オンライン</small></h1>
    </div>

    <div id="app" class="grid"></div>

    <p class="footer">おしりぷり～ん</p>
  </div>

  <!-- Firebase CDN（ご自身のプロジェクトに置き換えてください） -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

  <script>
    // =====================
    // ★ ここを書き換え ★
    // =====================
    const firebaseConfig = {
  apiKey: "AIzaSyBSU_LH7Jly8JJGLJ6-JW7Ily8MDUqgfAo",
  authDomain: "shiri-f440d.firebaseapp.com",
  databaseURL: "https://shiri-f440d-default-rtdb.firebaseio.com",
  projectId: "shiri-f440d",
  storageBucket: "shiri-f440d.firebasestorage.app",
  messagingSenderId: "721069605020",
  appId: "1:721069605020:web:8796f87f892541bfbc2d59"
    };

    // =====================
    // 初期化
    // =====================
    const appFB = firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // Utility
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
    const uid = () => Math.random().toString(36).slice(2,10);
    const now = ()=> Date.now();

    // =====================
    // デッキ構築
    // =====================
    // 文字カード：あ〜ら行（や行は3文字）= 43枚 ＋「わ」をもう1枚追加で計45枚
    const GOJYUON = [
      ['あ','い','う','え','お'],
      ['か','き','く','け','こ'],
      ['さ','し','す','せ','そ'],
      ['た','ち','つ','て','と'],
      ['な','に','ぬ','ね','の'],
      ['は','ひ','ふ','へ','ほ'],
      ['ま','み','む','め','も'],
      ['や','ゆ','よ'],
      ['ら','り','る','れ','ろ'],
    ];

    const LETTERS = GOJYUON.flat();
    // 「わ」を追加で1枚増やす（合計45枚）
    const LETTERS_WITH_EXTRA_WA = [...LETTERS, 'わ'];

    const WILD_NUMBERS = [
      { kind:'wildN', value:'ワイルド5' },
      { kind:'wildN', value:'ワイルド5' },
      { kind:'wildN', value:'ワイルド6' },
      { kind:'wildN', value:'ワイルド6' },
      { kind:'wildN', value:'ワイルド7+' },
      { kind:'wildN', value:'ワイルド7+' },
    ];

    const WILD_LINES = [
      'あ行','か行','さ行','た行','な行','は行','ま行','や行','ら行'
    ].map(v=>({ kind:'wildL', value:v }));

    function buildDeck() {
      const deck = [];
      for (const ch of LETTERS_WITH_EXTRA_WA) deck.push({ kind:'kana', value: ch });
      deck.push(...WILD_NUMBERS);
      deck.push(...WILD_LINES);
      return shuffle(deck);
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i=a.length-1;i>0;i--) {
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }

    // =====================
    // ルーム状態
    // =====================
    // rooms/{roomId} = {
    //   createdAt, started, deck, fieldCard, basketTop?, players:{ uid:{name, hand:[], reach:false, joinedAt} }, winnerUid?
    // }

    // 参加
    async function joinRoom(roomId, name, myUid) {
      const ref = db.ref(`rooms/${roomId}`);
      const snap = await ref.get();
      if (!snap.exists()) {
        await ref.set({
          createdAt: now(), started:false, deck:[], fieldCard:null, basketTop:null, winnerUid:null,
          players: {}
        });
      }
      await db.ref(`rooms/${roomId}/players/${myUid}`).set({ name, hand:[], reach:false, joinedAt: now() });
      return ref;
    }

    // 退出（ページ離脱）
    window.addEventListener('beforeunload', ()=>{
      if (state.roomId && state.myUid) {
        db.ref(`rooms/${state.roomId}/players/${state.myUid}`).remove();
      }
    });

    // ゲーム開始（山札生成→配る→場に1枚）
    async function startGame(roomId) {
      const roomRef = db.ref(`rooms/${roomId}`);
      await roomRef.transaction(room => {
        if (!room || room.started) return room;
        const deck = buildDeck();
        // 1人5枚
        const playerIds = Object.keys(room.players||{});
        for (const pid of playerIds) {
          room.players[pid].hand = deck.splice(0,5);
          room.players[pid].reach = false;
        }
        const fieldCard = deck.splice(0,1)[0];
        room.deck = deck;
        room.fieldCard = fieldCard;
        room.basketTop = null;
        room.lastMove = null; 
        room.started = true;
        room.winnerUid = null;
        return room;
      });
    }

    // 山札から1枚引く
    async function drawOne(roomId, pid) {
      await db.ref(`rooms/${roomId}`).transaction(room => {
        if (!room || !room.started) return room;
        const player = room.players?.[pid];
        if (!player) return room;
        if (room.deck.length === 0) return room;
        player.hand.push(room.deck.shift());
        return room;
      });
    }

    // カードを出す（早い者勝ち／同時は最初の書き込みが勝つ）
    async function playCard(roomId, pid, handIndex) {
  await db.ref(`rooms/${roomId}`).transaction(room => {
    if (!room?.started || room.winnerUid) return room;
    const player = room.players?.[pid];
    if (!player) return room;
    const card = player.hand[handIndex];
    if (!card) return room;

    const prevField = room.fieldCard ? { ...room.fieldCard } : null;

    // カードを場に出す
    player.hand.splice(handIndex, 1);
    room.fieldCard = card;

    // 一手戻し用の記録
    room.lastMove = { pid, card, prevField, ts: now() };

    // 勝利処理（口頭ルールは別）
    if (player.hand.length === 0) {
      room.winnerUid = pid;
    }
    return room;
  });
}

    // リーチ切替（可視化のみ）
    async function toggleReach(roomId, pid) {
      await db.ref(`rooms/${roomId}/players/${pid}/reach`).transaction(v => !v);
    }

    // リセット：手札を全捨て＋非ワイルドをトップにして場更新→(捨てた枚数+1)枚引く
    async function doReset(roomId, pid, topIndex) {
      await db.ref(`rooms/${roomId}`).transaction(room => {
        if (!room?.started || room.winnerUid) return room;
        const p = room.players?.[pid];
        if (!p) return room;
        const hand = p.hand;
        if (!hand || hand.length === 0) return room;
        const top = hand[topIndex];
        if (!top || top.kind !== 'kana') return room; // ワイルド以外をトップに
        const discardCount = hand.length;
        // すべて捨てる
        p.hand = [];
        // 山札から discardCount + 1 枚引く
        for (let i=0;i<discardCount+1;i++) {
          if (room.deck.length>0) p.hand.push(room.deck.shift());
        }
        // トップを新しい場に
        room.fieldCard = top;
        room.basketTop = top; // 参考表示
        room.lastMove = null;
        return room;
      });
    }
async function undoLast(roomId, pid) {
  await db.ref(`rooms/${roomId}`).transaction(room => {
    if (!room?.started) return room;
    const lm = room.lastMove;
    if (!lm || lm.pid !== pid) return room; // 最後に出した本人のみ

    // 直後に他の手が出ていないか（場が変わっていないか確認）
    const sameCard =
      JSON.stringify(room.fieldCard || {}) === JSON.stringify(lm.card || {});
    if (!sameCard) return room;

    const player = room.players?.[pid];
    if (!player) return room;

    // 手札に戻す
    player.hand.push(lm.card);
    // 場を元に戻す
    room.fieldCard = lm.prevField || null;

    // その一手で勝利になっていた場合は取り消し
    if (room.winnerUid === pid) room.winnerUid = null;

    room.lastMove = null;
    return room;
  });
}
    // =====================
    // UI（素のJS）
    // =====================
    const el = sel => document.querySelector(sel);

    const state = {
      screen: 'lobby', // lobby | room | game
      myUid: localStorage.getItem('shiritori_uid') || uid(),
      name: localStorage.getItem('shiritori_name') || '',
      roomId: '',
      roomRef: null,
      roomSnap: null,
    };

    function setScreen(s){ state.screen=s; render(); }

    function cardNode(card) {
  const div = document.createElement('div');
  div.className = 'card';

  // カード画像を使う
  const img = document.createElement('img');
  img.src = `cards/${card.id}.png`;  // 画像ファイル名をカードIDに合わせる
  img.alt = card.word;
  img.style.width = '100%';
  img.style.height = 'auto';

  // 画像がない場合に文字を表示するフォールバック
  img.onerror = () => {
    img.style.display = 'none';
    div.textContent = card.word;
  };

  div.appendChild(img);

  return div;
}

    function renderLobby(){
      const root = el('#app');
      root.innerHTML = '';

      const panel = document.createElement('div'); panel.className='panel grid';

      const nameWrap = document.createElement('div');
      nameWrap.innerHTML = `<label>ユーザー名</label><input id="name" placeholder="例：たろう" value="${state.name}">`;

      const roomWrap = document.createElement('div');
      roomWrap.innerHTML = `<label>ルームID（同じIDで集まる）</label><input id="room" placeholder="例：MutekiPass4545">`;

      const btnRow = document.createElement('div'); btnRow.className='row';
      const btnJoin = document.createElement('button'); btnJoin.className='primary'; btnJoin.textContent = '入室 / 作成';
      btnJoin.onclick = async () => {
        const name = document.getElementById('name').value.trim();
        const roomId = document.getElementById('room').value.trim();
        if (!name || !roomId) { alert('名前とルームIDを入力してください'); return; }
        state.name = name; state.roomId = roomId; localStorage.setItem('shiritori_name', name); localStorage.setItem('shiritori_uid', state.myUid);
        state.roomRef = await joinRoom(roomId, name, state.myUid);
        subscribeRoom();
        setScreen('room');
      };
      btnRow.appendChild(btnJoin);

      const howto = document.createElement('div'); howto.className='panel';
      howto.innerHTML = `
        <div class="section-title">遊び方（要約）</div>
        <ul>
          <li>各自5枚配布。場のカードの文字で始まり、自分の手札の文字で終わる3文字以上の単語を声で宣言しつつ素早く出す。</li>
          <li>順番なし。</li>
          <li>ワイルド（ナンバー/ライン）とリセット機能あり。</li>
          <li>最初に手札0枚の人が勝利（リーチ宣言＆最後4文字以上は口頭ルール）。</li>
          <li>うん～ち、プリッ</li>
        </ul>
        <p class="hint">※ 正誤判定やチャットは実装していません（ボイスチャット前提）。</p>
      `;

      panel.appendChild(nameWrap); panel.appendChild(roomWrap); panel.appendChild(btnRow);
      root.appendChild(panel); root.appendChild(howto);
    }

    function renderRoom(){
      const root = el('#app'); root.innerHTML='';
      const room = state.roomSnap?.val();
      const panel = document.createElement('div'); panel.className='panel';
      const title = document.createElement('div'); title.className='section-title'; title.textContent='入室中のプレイヤー';
      panel.appendChild(title);

      const playersDiv = document.createElement('div'); playersDiv.className='players';
      const players = room?.players ? Object.entries(room.players) : [];
      for (const [pid, p] of players) {
        const d = document.createElement('div'); d.className='player';
        d.innerHTML = `<strong>${p.name}</strong><span class="pill">${pid===state.myUid?'あなた':''}</span>`;
        playersDiv.appendChild(d);
      }
      panel.appendChild(playersDiv);

      const row = document.createElement('div'); row.className='row';
      const startBtn = document.createElement('button'); startBtn.className='success'; startBtn.textContent = 'ゲームスタート';
      startBtn.onclick = ()=> startGame(state.roomId);
      row.appendChild(startBtn);
      const backBtn = document.createElement('button'); backBtn.className='ghost'; backBtn.textContent = 'ロビーに戻る';
      backBtn.onclick = ()=>{ setScreen('lobby'); };
      row.appendChild(backBtn);

      panel.appendChild(row);
      el('#app').appendChild(panel);

      if (room?.started) setScreen('game');
    }

    function renderGame(){
      const root = el('#app'); root.innerHTML='';
      const room = state.roomSnap?.val(); if (!room) return;
      const me = room.players?.[state.myUid];

      // 上段：場・山札・勝者
      const top = document.createElement('div'); top.className='grid cols-3';

      const field = document.createElement('div'); field.className='panel';
      field.innerHTML = `<div class="section-title">場のカード</div>`;
      if (room.fieldCard) {
  const node = cardNode(room.fieldCard);

  // 直前の手を自分が出しており、まだ誰も次の手を出していない & 勝者未確定なら取り消し可
  const canUndo =
    room.lastMove &&
    room.lastMove.pid === state.myUid &&
    JSON.stringify(room.fieldCard || {}) === JSON.stringify(room.lastMove.card || {}) &&
    !room.winnerUid;

  if (canUndo) {
    node.style.cursor = 'pointer';
    node.title = '直前の一手を取り消す（クリック）';
    node.onclick = () => undoLast(state.roomId, state.myUid);
  }

  field.appendChild(node);
}
      top.appendChild(field);

      const deckBox = document.createElement('div'); deckBox.className='panel';
      deckBox.innerHTML = `<div class="section-title">山札</div>`;
      const stack = document.createElement('div'); stack.className='stack';
      const back = document.createElement('div'); back.className='card back';
      const count = document.createElement('div'); count.className='count'; count.textContent = `${room.deck?.length||0} 枚`;
      stack.appendChild(back); stack.appendChild(count); deckBox.appendChild(stack);
      top.appendChild(deckBox);

      const status = document.createElement('div'); status.className='panel';
      status.innerHTML = `<div class="section-title">ステータス</div>`;
      if (room.winnerUid) {
        const winnerName = room.players?.[room.winnerUid]?.name || '？？？';
        const win = document.createElement('div'); win.innerHTML = `<strong style="color:var(--ok)">勝者：${winnerName}</strong>`;
        status.appendChild(win);
      } else {
        const hint = document.createElement('div'); hint.className='hint';
        hint.innerHTML = `3文字以上で <span class="kbd">場の頭</span> → <span class="kbd">自分の末尾</span>。順番なし。`;
        status.appendChild(hint);
      }
      top.appendChild(status);

      root.appendChild(top);

      // 中段：他プレイヤー
      const others = document.createElement('div'); others.className='panel';
      others.innerHTML = `<div class="section-title">他のプレイヤー（手札は裏）</div>`;
      const othersWrap = document.createElement('div'); othersWrap.className='players';
      for (const [pid,p] of Object.entries(room.players||{})) {
        if (pid===state.myUid) continue;
        const d = document.createElement('div'); d.className='player';
        const backs = new Array((p.hand||[]).length).fill(0).map(()=>'<span class="card small back"></span>').join('');
        d.innerHTML = `<strong>${p.name}</strong> <span class="pill">${(p.hand||[]).length}枚</span> <span class="pill">${p.reach? 'リーチ宣言中' : '—'}</span> <div class="row">${backs}</div>`
        othersWrap.appendChild(d);
      }
      others.appendChild(othersWrap);
      root.appendChild(others);

      // 下段：自分の手札と操作
      const mine = document.createElement('div'); mine.className='panel';
      mine.innerHTML = `<div class="section-title">自分の手札</div>`;
      const handDiv = document.createElement('div'); handDiv.className='cards';
      me?.hand?.forEach((c, idx)=>{
        const n = cardNode(c);
        n.title = 'クリックで場に出す（口頭で単語を言いながら！）';
        n.style.cursor='pointer';
        n.onclick = ()=> playCard(state.roomId, state.myUid, idx);
        handDiv.appendChild(n);
      });
      mine.appendChild(handDiv);

      const controls = document.createElement('div'); controls.className='row';
      const drawBtn = document.createElement('button'); drawBtn.textContent = '1枚引く'; drawBtn.onclick=()=>drawOne(state.roomId, state.myUid);
      const reachBtn = document.createElement('button'); reachBtn.textContent = me?.reach? 'リーチ解除' : 'リーチ宣言'; reachBtn.onclick=()=>toggleReach(state.roomId, state.myUid);
      const resetBtn = document.createElement('button'); resetBtn.className='danger'; resetBtn.textContent = 'リセット（全捨て→+1枚）';
      resetBtn.onclick = ()=>{
        if (!me?.hand?.length) return;
        // 非ワイルドトップの選択
        const options = me.hand.map((c,i)=>({i,txt:`${i+1}: ${c.value}${c.kind!=='kana'?'（×ワイルド）':''}`}));
        const sel = prompt('トップにする非ワイルドカードの番号を入力\n' + options.map(o=>o.txt).join('\n'));
        const topIdx = Number(sel)-1;
        if (Number.isFinite(topIdx) && me.hand[topIdx] && me.hand[topIdx].kind==='kana') {
          doReset(state.roomId, state.myUid, topIdx);
        } else {
          alert('非ワイルドの番号を選んでください');
        }
      };
      controls.appendChild(drawBtn);
      controls.appendChild(reachBtn);
      controls.appendChild(resetBtn);
      mine.appendChild(controls);

      const tips = document.createElement('div'); tips.className='hint';
      tips.innerHTML = '濁音・半濁音は自由に付け外しOK（例：は/ば/ぱ）。最後の1枚は4文字以上（口頭ルール）。';
      mine.appendChild(tips);

      root.appendChild(mine);
    }

    function render(){
      if (state.screen==='lobby') renderLobby();
      if (state.screen==='room') renderRoom();
      if (state.screen==='game') renderGame();
    }

    function subscribeRoom(){
      if (!state.roomRef) return;
      state.roomRef.on('value', snap => { state.roomSnap = snap; if (state.screen!=='lobby') render(); });
    }

    // 初期表示
    render();
  </script>
</body>
</html>
